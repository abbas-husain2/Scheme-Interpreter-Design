//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst implements GJVisitor<ReturnableValue,Environment> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public ReturnableValue visit(NodeList n, Environment parameters) {
      ReturnableValue _ret=(ReturnableValue)new ArrayList<>();
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,parameters);
         _count++;
      }
      return _ret;
   }

   public ReturnableValue visit(NodeListOptional n, Environment parameters) {
      if ( n.present() ) {
         ReturnableValue _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,parameters);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public ReturnableValue visit(NodeOptional n, Environment parameters) {
      if ( n.present() )
         return n.node.accept(this,parameters);
      else
         return null;
   }

   public ReturnableValue visit(NodeSequence n, Environment parameters) {
      ReturnableValue _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,parameters);
         _count++;
      }
      return _ret;
   }

   public ReturnableValue visit(NodeToken n, Environment parameters) { return null; }

   //
   // User-generated visitor methods below
   //



   /**
    * f0 -> ( Line() )*
    * f1 -> <EOF>
    */
   public ReturnableValue visit(Goal n, Environment parameters) {

      n.f0.accept(this, parameters);
      n.f1.accept(this, parameters);
     return null;
   }

   /**
    * f0 -> Expression()
    */
   public ReturnableValue visit(Line n, Environment parameters) {
      ReturnableValue rv1=null;
      rv1 = (ReturnableValue)n.f0.accept(this, parameters);
      if(!(rv1 instanceof IntegerType) && !(rv1 instanceof IntegerList) && !(rv1 instanceof BooleanType)&&rv1 !=null ){
         ((Procedure)rv1).show();
      }else if(!(rv1 instanceof IntegerType) && !(rv1 instanceof Procedure) && !(rv1 instanceof IntegerList)&&rv1!=null ){
         rv1.show();
      }else if(!(rv1 instanceof BooleanType) && !(rv1 instanceof Procedure) && !(rv1 instanceof IntegerList)&&rv1 !=null){
         rv1.show();
      }else if(!(rv1 instanceof IntegerType) && !(rv1 instanceof Procedure) && !(rv1 instanceof BooleanType)&&rv1 !=null){
         rv1.show();
      }else{
         rv1=null;
      }
      return rv1;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ListExpr()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | MultiplyExpression()
    *       | DivideExpression()
    *       | GTExpression()
    *       | LTExpression()
    *       | EQExpression()
    *       | IfExpression()
    *       | DefineExpression()
    *       | Assignment()
    *       | ProcedureExp()
    *       | CarExpr()
    *       | CdrExpr()
    *       | Application()
    */
   public ReturnableValue visit(Expression n, Environment parameters) {
      ReturnableValue _ret = n.f0.accept(this, parameters);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public ReturnableValue visit(IntegerLiteral n, Environment parameters) {
      IntegerType integ;
      integ=new IntegerType();
      integ.objectInteger=Integer.parseInt(n.f0.tokenImage);
      return integ;     // Returns Integer Object
   }

   /**
    * f0 -> "#t"
    */
   public ReturnableValue visit(TrueLiteral n, Environment parameters) {
      BooleanType rv1=null;
      rv1=new BooleanType();
      rv1.name=n.f0.tokenImage;
      return rv1; //Returns Boolean Object
   }

   /**
    * f0 -> "#f"
    */
   public ReturnableValue visit(FalseLiteral n, Environment parameters) {
      BooleanType rv1=null;
      rv1=new BooleanType();
      rv1.name=n.f0.tokenImage;
      return rv1; //Returns Boolean Object
   }

   /**
    * f0 -> "("
    * f1 -> "list "
    * f2 -> ( IntegerLiteral() )*
    * f3 -> ")"
    */
   public ReturnableValue visit(ListExpr n, Environment parameters) {

      /*  This Method creates an object of IntegerList and adds the elements of the list to the array List of IntegerList and then returns the integerList Object*/

      IntegerList arr=new IntegerList();
      IntegerType abc = new IntegerType();
      for(Node var:n.f2.nodes){

            arr.array.add(Integer.parseInt(((IntegerLiteral)var).f0.tokenImage));
      }

      return arr;
   }

   /**
    * f0 -> "("
    * f1 -> "+"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public ReturnableValue visit(PlusExpression n, Environment parameters) {
      // This Method first Checks whether the return type of the two expressions is Integer Type or not if they are then it adds the two Integer
      ReturnableValue rv1=n.f2.accept(this, parameters);
      ReturnableValue rv2=n.f3.accept(this, parameters);

      IntegerType additionResult=new IntegerType();



      if((rv1 instanceof IntegerType) && (rv2 instanceof IntegerType)){
            IntegerType int1=(IntegerType) rv1;
            IntegerType int2=(IntegerType)rv2;
            if(int1==null || int2==null){
               return null;
            }else if(int1.objectInteger==0){
               additionResult.objectInteger=int2.objectInteger;
            }else if(int2.objectInteger==0){
               additionResult.objectInteger=int1.objectInteger;
            }else{
               additionResult.objectInteger=int2.objectInteger+int1.objectInteger;
            }


      }else{
         System.out.println("Error : Expected Integers");
         System.exit(0);
      }

      return additionResult;
   }

   /**
    * f0 -> "("
    * f1 -> "-"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public ReturnableValue visit(MinusExpression n, Environment parameters) {
      // This Method first Checks whether the return type of the two expressions is Integer Type or not if they are then it subtracts the two Integer
      ReturnableValue rv1=n.f2.accept(this, parameters);
      ReturnableValue rv2=n.f3.accept(this, parameters);

      IntegerType subtractionResult=new IntegerType();



      if((rv1 instanceof IntegerType) && (rv2 instanceof IntegerType)){
         IntegerType int1=(IntegerType) rv1;
         IntegerType int2=(IntegerType)rv2;
         if(int1==null || int2==null){
            return null;
         }else if(int1.objectInteger==0){
            subtractionResult.objectInteger=-1*(int2.objectInteger);
         }else if(int2.objectInteger==0){
            subtractionResult.objectInteger=int1.objectInteger;
         }else{
            subtractionResult.objectInteger=int1.objectInteger-int2.objectInteger;
         }


      }else{
         System.out.println("Error : Expected Integers");
         System.exit(0);
      }

      return subtractionResult;
   }

   /**
    * f0 -> "("
    * f1 -> "*"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public ReturnableValue visit(MultiplyExpression n, Environment parameters) {
      // This Method first Checks whether the return type of the two expressions is Integer Type or not if they are then it multiplies the two Integer
      ReturnableValue rv1=n.f2.accept(this, parameters);
      ReturnableValue rv2=n.f3.accept(this, parameters);

      IntegerType multiplicationResult=new IntegerType();



      if((rv1 instanceof IntegerType) && (rv2 instanceof IntegerType)){
         IntegerType int1=(IntegerType) rv1;
         IntegerType int2=(IntegerType)rv2;
         if(int1==null || int2==null){
            return null;
         }else if(int1.objectInteger==1){
            multiplicationResult.objectInteger=int2.objectInteger;
         }else if(int2.objectInteger==1){
            multiplicationResult.objectInteger=int1.objectInteger;
         }else if(int1.objectInteger==0 || int2.objectInteger==0){
            multiplicationResult.objectInteger=0;
         }else{
            multiplicationResult.objectInteger=int2.objectInteger*int1.objectInteger;
         }


      }else{
         System.out.println("Error : Expected Integers");
         System.exit(0);
      }

      return multiplicationResult;
   }

   /**
    * f0 -> "("
    * f1 -> "/"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public ReturnableValue visit(DivideExpression n, Environment parameters) {
      // This Method first Checks whether the return type of the two expressions is Integer Type or not if they are then it divides the two Integer
      ReturnableValue rv1=n.f2.accept(this, parameters);
      ReturnableValue rv2=n.f3.accept(this, parameters);

      IntegerType divisionResult=new IntegerType();



      if((rv1 instanceof IntegerType) && (rv2 instanceof IntegerType)){
         IntegerType int1=(IntegerType) rv1;
         IntegerType int2=(IntegerType)rv2;
         if(int1==null || int2==null){
            return null;
         }else if(int2.objectInteger==0){
            System.out.println("Number can not be divided by zero ");
            System.exit(0);
         }else if(int2.objectInteger==1){
            divisionResult.objectInteger=int1.objectInteger;
         }else{
            divisionResult.objectInteger=int1.objectInteger/int2.objectInteger;
         }


      }else{
         System.out.println("Error : Expected Integers");
         System.exit(0);
      }

      return divisionResult;
   }

   /**
    * f0 -> "("
    * f1 -> ">"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public ReturnableValue visit(GTExpression n, Environment parameters) {
      // This Method first Checks whether the return type of the two expressions is Integer Type or not if they are then if the first Integer is greater than the second objectInteger it returns True else it returns False
      ReturnableValue rv1=n.f2.accept(this, parameters);
      ReturnableValue rv2=n.f3.accept(this, parameters);

      BooleanType bool=new BooleanType();



      if((rv1 instanceof IntegerType) && (rv2 instanceof IntegerType)){
         IntegerType int1=(IntegerType) rv1;
         IntegerType int2=(IntegerType)rv2;
         if(int1==null || int2==null){
            return null;
         }else if(int1.objectInteger<=int2.objectInteger){
            bool.name="#f";
         }else{
            bool.name="#t";
         }


      }else{
         System.out.println("Error : Expected Integers");
         System.exit(0);
      }

      return bool;
   }

   /**
    * f0 -> "("
    * f1 -> "<"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public ReturnableValue visit(LTExpression n, Environment parameters) {
      // This Method first Checks whether the return type of the two expressions is Integer Type or not if they are then if the first Integer is less than the second objectInteger it returns True else it returns False

      ReturnableValue rv1=n.f2.accept(this, parameters);
      ReturnableValue rv2=n.f3.accept(this, parameters);

      BooleanType bool=new BooleanType();



      if((rv1 instanceof IntegerType) && (rv2 instanceof IntegerType)){
         IntegerType int1=(IntegerType) rv1;
         IntegerType int2=(IntegerType)rv2;
         if(int1==null || int2==null){
            return null;
         }else if(int1.objectInteger>=int2.objectInteger){
            bool.name="#f";
         }else{
            bool.name="#t";
         }


      }else{
         System.out.println("Error : Expected Integers");
         System.exit(0);
      }

      return bool;
   }

   /**
    * f0 -> "("
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public ReturnableValue visit(EQExpression n, Environment parameters) {
      // This Method first Checks whether the return type of the two expressions is Integer Type or not if they are then if the first Integer is equal to the second objectInteger it returns True else it returns False

      ReturnableValue rv1=n.f2.accept(this, parameters);
      ReturnableValue rv2=n.f3.accept(this, parameters);

      BooleanType bool=new BooleanType();



      if((rv1 instanceof IntegerType) && (rv2 instanceof IntegerType)){
         IntegerType int1=(IntegerType) rv1;
         IntegerType int2=(IntegerType)rv2;
         if(int1==null || int2==null){
            return null;
         }else if(int1.objectInteger>int2.objectInteger){
            bool.name="#f";
         }else if(int1.objectInteger<int2.objectInteger){
            bool.name="#f";
         }else{
            bool.name="#t";
         }


      }else{
         System.out.println("Error : Expected Integers");
         System.exit(0);
      }

      return bool;
   }

   /**
    * f0 -> "("
    * f1 -> "if"
    * f2 -> Expression()
    * f3 -> Expression()
    * f4 -> Expression()
    * f5 -> ")"
    */
   public ReturnableValue visit(IfExpression n, Environment parameters) {
   // This method checks the if condition if the condition returns true the first expression is executed else the second expression is executed.
      ReturnableValue rv1=null;
      BooleanType bool=(BooleanType)n.f2.accept(this, parameters);
      if(bool.name.equals("#f")){
       rv1=n.f4.accept(this, parameters);
      }else if(bool.name.equals("#t")){
         rv1=n.f3.accept(this, parameters);
      }
      return rv1;
   }

   /**
    * f0 -> "("
    * f1 -> "define"
    * f2 -> Identifier()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public ReturnableValue visit(DefineExpression n, Environment parameters) {
      // This Method Maps the Identifier with the expression
      ReturnableValue rv1=n.f3.accept(this, parameters);
      String id =(String) n.f2.f0.tokenImage;
      if(!(rv1 instanceof IntegerType) && !(rv1 instanceof Procedure) && !(rv1 instanceof IntegerList)){
         BooleanType bool=null;
         bool=(BooleanType)rv1;
         parameters.hashMap.put(id,bool);
      }else if(!(rv1 instanceof BooleanType)&&!(rv1 instanceof Procedure)&& !(rv1 instanceof IntegerList)){
         IntegerType integ=null;
         integ=(IntegerType)rv1;
         parameters.hashMap.put(id,integ);
      }else if(!(rv1 instanceof BooleanType)&&!(rv1 instanceof IntegerType)&& !(rv1 instanceof IntegerList)){
         Procedure proc=null;
         proc=(Procedure)rv1;
         parameters.hashMap.put(id,proc);
      }else{
         IntegerList intlist=null;
         intlist=(IntegerList)rv1;
         parameters.hashMap.put(id,intlist);
      }

      return null;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public ReturnableValue visit(Identifier n, Environment parameters) {
      //This Method returns the Returnable value object associated with the Identifier
      ReturnableValue rv1=null;
      String id =n.f0.tokenImage;
      Procedure proc=null;
      if(parameters.hashMap.containsKey(id)){
         rv1=parameters.hashMap.get(id);
         if(!(rv1 instanceof IntegerType)&&!(rv1 instanceof Procedure)&& !(rv1 instanceof IntegerList)){
            return rv1;
         }else if(!(rv1 instanceof BooleanType)&&!(rv1 instanceof Procedure)&& !(rv1 instanceof IntegerList)){
            return rv1;
         }else if(!(rv1 instanceof BooleanType)&&!(rv1 instanceof Procedure)&& !(rv1 instanceof IntegerType)){
            return rv1;
         }else{
            proc=new Procedure();
            proc=(Procedure)rv1;
            proc.name=id;

            return proc;
         }
      }else if(parameters.linkedEnvironment !=null) {

         if (parameters.linkedEnvironment.hashMap.containsKey(id)) {
            rv1 = parameters.linkedEnvironment.hashMap.get(id);
            if (!(rv1 instanceof BooleanType)&&!(rv1 instanceof Procedure)&& !(rv1 instanceof IntegerList)) {
               return rv1;
            } else if (!(rv1 instanceof IntegerType)&&!(rv1 instanceof Procedure)&& !(rv1 instanceof IntegerList)) {
               return rv1;
            } else if (!(rv1 instanceof BooleanType)&&!(rv1 instanceof Procedure)&& !(rv1 instanceof IntegerType)) {
               return rv1;
            } else {
               proc = new Procedure();
               proc = (Procedure) rv1;
               proc.name = id;

               return proc;
            }
         } else {
            System.out.println("Error : "+id+" Identifier Not Found");
            System.exit(0);
         }
      }

      else{
         System.out.println("Error : "+id+" Identifier Not Found");
         System.exit(0);
      }

      //System.out.println((String) x);
      return rv1;
   }

   /**
    * f0 -> "("
    * f1 -> "car"
    * f2 -> Expression()
    * f3 -> ")"
    */
   public ReturnableValue visit(CarExpr n, Environment parameters) {
      // This Method Returns the first element of the List.
      IntegerList rv1=null;
      IntegerType integ=new IntegerType();

      rv1=(IntegerList)n.f2.accept(this, parameters);
      integ.objectInteger=rv1.array.get(0);

      return integ;
   }

   /**
    * f0 -> "("
    * f1 -> "cdr"
    * f2 -> Expression()
    * f3 -> ")"
    */
   public ReturnableValue visit(CdrExpr n, Environment parameters) {
      //This Method returns the Integerlist except the first element.
      IntegerList rv1=null;
      IntegerType integ=new IntegerType();

      rv1=(IntegerList)n.f2.accept(this, parameters);
      rv1.array.remove(0);

      return rv1;
   }

   /**
    * f0 -> "("
    * f1 -> "set!"
    * f2 -> Identifier()
    * f3 -> Expression()
    * f4 -> ")"
    */
   public ReturnableValue visit(Assignment n, Environment parameters) {
      // This method maps the Identifier with the Returnable Object.
      ReturnableValue rv1=null;
      String id=n.f2.f0.tokenImage;
      rv1=(ReturnableValue)n.f3.accept(this,parameters);
      if(parameters.hashMap.containsKey(id)){
         parameters.hashMap.put(id,rv1);
      }else if((parameters.linkedEnvironment!=null) && (parameters.linkedEnvironment.hashMap.containsKey(id))) {
            parameters.linkedEnvironment.hashMap.put(id,rv1);
      }else{
         System.out.println("Error : "+id+" Identifier Not Found");
         System.exit(0);
      }

      return null;
   }

   /**
    * f0 -> "("
    * f1 -> "lambda"
    * f2 -> "("
    * f3 -> ( Identifier() )*
    * f4 -> ")"
    * f5 -> Expression()
    * f6 -> ")"
    */
   public ReturnableValue visit(ProcedureExp n, Environment parameters) {
      //This method creates a new Procedure Object and intialises its all the fields.
   Procedure proc =new Procedure();
   for(Node var: n.f3.nodes){
      proc.arr.add(((Identifier)var).f0.tokenImage);
   }
   proc.env=parameters;
   proc.statements=n.f5;
      
      return proc;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ( Expression() )*
    * f3 -> ")"
    */
   public ReturnableValue visit(Application n, Environment parameters) {
      // This Method creates a new Environment and in that environment it maps the formal parameters with actual arguments and set its environment to its enclosing environment (proc). Then we evaluate the expression of the procedure (we pass the new environment as the argument) and return its value.
      ReturnableValue rv1=null;
      Procedure proc=null;
      Environment env=new Environment();
      proc=(Procedure)n.f1.accept(this,parameters);
      if(proc.arr.size()==n.f2.size()){
         for(int i=0;i<proc.arr.size();i++){
            env.hashMap.put(proc.arr.get(i),(n.f2.nodes.get(i).accept(this,parameters)));
         }
         env.linkedEnvironment=proc.env;
         rv1=proc.statements.accept(this,env);
      }else{
         System.out.println("Number of formal argument does not match number of actual parameters");
         System.exit(0);
      }

      return rv1;
   }

}
